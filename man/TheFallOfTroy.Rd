% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/WoodenHorse-class.R
\name{TheFallOfTroy}
\alias{TheFallOfTroy}
\alias{GreekSoldier}
\alias{Nightfall}
\alias{HelenOfTroy}
\title{Hiding S4 objects as S3 vectors}
\usage{
GreekSoldier(x)

Nightfall(x)

HelenOfTroy(x)
}
\arguments{
\item{x}{For \code{GreekSoldier()}, an S4 Vector class object.\cr For
\code{Nightfall()} and \code{HelenOfTroy()}, an S3 \code{WoodenHorse} class
object.}
}
\description{
There are some limitations to getting S4 objects past the
  internals of the ggplot2 system. One of these is a hard check with
  \code{rlang::is_vector} on data.frame columns, which will throw an error
  when the column is an S4 object. To work around these limitations, we
  disguise S4 Vectors classes as S3 vectors from the vctrs package.
}
\details{
Calling \code{GreekSoldier()} on an S4 Vector object will generate
  an object of the class \code{WoodenHorse} of the same length as the input,
  where the original S4 Vector is inside the \code{WoodenHorse} object as an
  attribute.

  Calling \code{Nightfall()} on the \code{WoodenHorse} object, will restore
  the input given to \code{GreekSoldier} to an S4 object.

  Calling \code{HelenOfTroy()} on the \code{WoodenHorse} object returns the
  class of the \code{GreekSoldier} attribute.

  Encoding the \code{WoodenHorse} object as a \code{vctrs_vctr} object allows
  us to pass the \code{rlang::is_vector} check and gives us nice options to
  preserve attributes over subsetting and concatenation operations.
}
\examples{
# Making an S4 object
Anticlus <- Rle(1:10, 10:1)

# Rle object does not pass is_vector test
rlang::is_vector(Anticlus)

# Disguising the object as S3 vector
VictoryTrophy <- GreekSoldier(Anticlus)
class(VictoryTrophy) # A WoodenHorse

# WoodenHorse passes is_vector test
rlang::is_vector(VictoryTrophy)

# Inspecting the class of WoodenHorse
HelenOfTroy(VictoryTrophy) # Rle

# Restoring WoodenHorse to S4 object
Nightfall(VictoryTrophy)
}
