# Main function -----------------------------------------------------------

#'Setting up cytogenetic bands
#'
#'Sets up the necessary \code{ggproto} objects and methods to plot ideograms
#'next to plot panels.
#'
#'@param bands data.frame with the following columns in order:
#'  \describe{\item{\code{character}  chrom}{Chromosome} \item{\code{numeric}
#'  chromStart}{Start position in chromosome sequence} \item{\code{numeric}
#'  chromEnd}{End position in chromosome sequence} \item{\code{character}
#'  name}{Name of cytogenetic band} \item{\code{factor}  gieStain}{Giemsa stain
#'  results}}
#'@param colourmap named vector of colours with names matching factor levels in
#'  \code{bands$gieStain}.
#'@param gpars \code{gpar} object created by \code{\link[grid]{gpar}}
#'
#'@return None
#'
#'@details \code{bands} is assumed to follow the cytobands file format, but does
#'  not need matching column names. \code{bands$name} is not used but cannot be
#'  \code{NULL}. Special behaviour is applied to the "acen" factor level in
#'  \code{bands$gieStain}, as these are assumed to be the centromeres.
#'
#'  Cytobands data can be downloaded from the Table Browser of the
#'  \href{https://genome.ucsc.edu/cgi-bin/hgTables}{UCSC Genome Browser} by
#'  setting the 'Group' to 'Mapping and Sequencing' and 'Track' to 'Chromosome
#'  Bands (Ideogram)' for the available organisms.  Alternatively, the
#'  \pkg{AnnotationHub} Bioconductor package can be used to retrieve cytoband
#'  information via an R interface.
#'
#'  An appropriate \code{colourmap} vector for default Giemsa stain results can
#'  be generated by calling
#'  \code{\link[biovizBase:getBioColor]{getBioColor}}\code{("CYTOBAND")} from
#'  the \pkg{biovizBase} Bioconductor Package.
#'
#' @examples
#' cytobands <- example_cytobands()
#' colourmap <- example_cytoband_colours()
#' setup_cytobands(cytobands, colourmap)
#'
#'@seealso \href{https://genome.ucsc.edu/}{UCSC Genome Browser}
#'  \code{\link[biovizBase]{getBioColor}}
#'  \code{\link[AnnotationHub]{AnnotationHub-package}}
#'  \code{\link[grid]{gpar}}
#'
#'@export
setup_cytobands <- function(bands, colourmap, gpars = gpar()){

  # Split up by chromosome
  bands <- split(bands, bands[, 1])

  # Loop over chromosomes
  ideograms <- lapply(bands, function(ideo){

    nbands <- nrow(ideo)
    centro <- which(ideo[, 5] == "acen")
    centro <- if (length(centro) > 0) range(centro) else c(0,0)

    # Format ideogram outline as polygon
    poly <- c(ideo[c(1, centro[1]), 2],
              ideo[c(centro[2], nbands), 3])
    poly <- data.frame(x = c(poly, rev(poly)),
                       y = c(0, 0, 1, 1))

    keep <- !(seq_len(nbands) %in% centro)
    # Setup bands as rectangles
    rects <- data.frame(x = rowMeans(ideo[, 2:3]),
                        y = 0.5,
                        width = (ideo[, 3] - ideo[, 2]),
                        height = 1,
                        fill = colourmap[as.character(ideo[, 5])],
                        stringsAsFactors = F)[keep,]

    return(list(polygon = poly, rectangles = rects))
  })

  # Save additional variables as attributes
  attr(ideograms, "gpars") <- gpars
  if ("acen" %in% names(colourmap)){
    attr(ideograms, "centro.col") <- colourmap[["acen"]]
  } else {
    attr(ideograms, "centro.col") <- "red"
  }

  # Assign ggprotos
  assign("FacetIdeo",
         ggproto("FacetIdeo", Facet,
                 ideograms = ideograms,
                 render.ideo = render.ideo),
         envir = tbcache)

  assign("FacetIdeoGrid",
         ggproto("FacetIdeoGrid", get("FacetIdeo", tbcache),
                 compute_layout = ggplot2::FacetGrid$compute_layout,
                 map_data = ggplot2::FacetGrid$map_data,
                 draw_panels = draw_ideo_panels_grid),
         envir = tbcache)

  assign("FacetIdeoWrap",
         ggproto("FacetIdeoWrap", get("FacetIdeo", tbcache),
                 compute_layout = ggplot2::FacetWrap$compute_layout,
                 map_data = ggplot2::FacetWrap$map_data,
                 draw_panels = draw_ideo_panels_wrap),
         envir = tbcache)
}

# Helpers -----------------------------------------------------------------

# Make a small environment so doesn't clog user environment
tbcache <- new.env()

#' Clear the cytoband cache.
#'
#' The ggnomics package creates a small environment to store ideogram related
#' functions and data. When switching organisms in a single session, it might be
#' useful to clear the ideogram data from the previous organism to make room
#' for the current organism.
#'
#' @export
#'
#' @examples
#' clear_cytoband_cache()
clear_cytoband_cache <- function() {
  env <- getFromNamespace("tbcache", "ggnomics")
  objects <- ls(env)
  if (length(objects) > 0) {
    rm(list = objects, envir = env)
  }
}



#' Ideogram renderer
#'
#' @param chr a chromosome name.
#' @param orient a character "x" or "y".
#' @param ranges the limits of the panel.
#' @param theme the theme of the plot.
#' @param high.col a highlight colour.
#' @param ideodat the data for ideograms.
#'
#' @return a grob with an ideogram
#' @keywords internal
render.ideo <- function(chr, orient = "x", ranges, theme, high.col, ideodat){

  # Return empty grob on absense of proper chr
  if (is.null(chr) | is.na(chr)){
    return(nullGrob())
  }

  # Retrieve data
  i <- which(grepl(paste0(chr, "$"), names(ideodat), ignore.case = T))
  if (length(i) == 0){
    return(nullGrob())
  }
  dat <- ideodat[[i]]

  # Format ranges
  this.range <- ranges[[paste0(orient, ".range")]]
  if (is.unsorted(abs(this.range))) {
    this.range <- abs(this.range)
    reversed <- TRUE
  } else {
    reversed <- FALSE
  }

  maxlim <- max(dat$polygon$x,
                dat$rectangles$x + 0.5 * dat$rectangles$width,
                this.range)
  minlim <- min(dat$polygon$x,
                dat$rectangles$x - 0.5 * dat$rectangles$width,
                this.range)

  # Ratio adjustments for highlights
  if (!is.na(high.col)){
    ratio <- 2 / (1 + sqrt(5))
  } else {
    ratio <- 1
  }

  # Format data coordinates
  poly <- data.frame(
    x = (dat$polygon$x - minlim) / (maxlim - minlim),
    y = (dat$polygon$y - 0.5) * ratio + 0.5
  )
  rect <- data.frame(
    x = (dat$rectangles$x - minlim) / (maxlim - minlim),
    y = dat$rectangles$y,
    width  = dat$rectangles$width / (maxlim - minlim),
    height = dat$rectangles$height * ratio
  )
  hi.light <- data.frame(
    x = (mean(this.range[1:2]) - minlim) / (maxlim - minlim),
    y = 0.5,
    width  = diff(this.range[1:2]) / (maxlim - minlim),
    height = 1
  )

  # Reverse x if scale is reversed
  if (reversed) {
    poly$x <- 1 - poly$x
    rect$x <- 1 - rect$x
    hi.light$x <- 1 - hi.light$x
  }

  # Switch x/y when orientation is y
  if (orient == "y") {
    colnames(poly) <- c("y", "x")
    colnames(rect) <- c("y", "x", "height", "width")
    colnames(hi.light)  <- c("y", "x", "height", "width")
  }

  # Setup graphical parameters
  rect.gp <- centro.gp <- outline.gp <- hifill.gp <- hiline.gp <-
    attr(ideodat, "gpar")
  rect.gp$col <- centro.gp$col <- outline.gp$fill <-
    hifill.gp$col <- hiline.gp$fill <- NA
  rect.gp$fill <- dat$rectangles$fill
  centro.gp$fill <- attr(ideodat, "centro.col")
  outline.gp$col <- theme$line$colour
  hifill.gp$fill <- hiline.gp$col <- high.col

  # Build grobs
  bands   <- do.call(rectGrob,    c(rect, list(gp = rect.gp)))
  centro  <- do.call(polygonGrob, c(poly, list(gp = centro.gp)))
  outline <- do.call(polygonGrob, c(poly, list(gp = outline.gp)))

  if (!is.na(high.col)) {
    # Add highlights
    hi.fill <- do.call(rectGrob, c(hi.light, list(gp = hifill.gp)))
    hi.line <- do.call(rectGrob, c(hi.light, list(gp = hiline.gp)))
    # Combine grobs
    tree <- grobTree(hi.fill, centro, bands, outline, hi.line)
  } else {
    tree <- grobTree(centro, bands, outline)
  }

  return(tree)
}


# ggproto methods ---------------------------------------------------------

# These are not already in ggproto objects because these are build on the fly
# depending on the cytobands data used.

#' Drawing panels for facet_ideogrid()
#'
#' This function handles the assembly of panels into a
#' \code{\link[gtable]{gtable}} object. This is a method of the "FacetIdeoGrid"
#' \code{\link[ggplot2]{ggproto}} class. This method recieves from objects
#' elsewhere in the plot a list of \code{\link[grid]{grid.grob}} with the
#' contents of panels. This method is responsible for decorating the panels with
#' axes, strips and ideograms and positioning these together in a gtable.
#'
#' @return A gtable object
#'
#' @details Since this is a method of a class, this function should only be used
#'   indirectly by users.
#'
#' @keywords internal
draw_ideo_panels_grid <- function(
  panels, layout, x_scales, y_scales, ranges, coord, data, theme, params, self
){
  if ( (params$free$x || params$free$y) && !coord$is_free()){
    stop(.int$snake_class(coord), " doesn't support free scales", call. = F)
  }
  ideo.size <- params$ideo.size
  cols <- which(layout$ROW == 1)
  rows <- which(layout$COL == 1)
  axes <- render_axes(ranges[cols], ranges[rows],
                      coord, theme, transpose = T)
  col_vars <- unique(layout[names(params$cols)])
  row_vars <- unique(layout[names(params$rows)])
  attr(col_vars, "type")  <- "cols"
  attr(col_vars, "facet") <- "grid"
  attr(row_vars, "type")  <- "rows"
  attr(row_vars, "facet") <- "grid"
  strips <- render_strips(col_vars, row_vars, params$labeller, theme)
  aspect_ratio <- theme$aspect.ratio
  if (is.null(aspect_ratio) && !params$free$x && !params$free$y){
    aspect_ratio <- coord$aspect(ranges[[1]])
  }
  if (is.null(aspect_ratio)){
    aspect_ratio <- 1
    respect <- FALSE
  } else {
    respect <- TRUE
  }
  ncol <- max(layout$COL)
  nrow <- max(layout$ROW)
  panel_table <- matrix(panels, nrow = nrow, ncol = ncol, byrow = TRUE)
  if (params$space_free$x){
    ps <- layout$PANEL[layout$ROW == 1]
    widths <- vapply(ps, function(i) diff(ranges[[i]]$x.range),
                     numeric(1))
    panel_widths <- unit(widths, "null")
  } else {
    panel_widths <- rep(unit(1, "null"), ncol)
  }
  if (params$space_free$y) {
    ps <- layout$PANEL[layout$COL == 1]
    heights <- vapply(ps, function(i) diff(ranges[[i]]$y.range),
                      numeric(1))
    panel_heights <- unit(heights, "null")
  } else {
    panel_heights <- rep(unit(1 * aspect_ratio, "null"),
                         nrow)
  }
  panel_table <- gtable_matrix(
    "layout", panel_table, panel_widths,
    panel_heights, respect = respect, clip = coord$clip,
    z = matrix(1, ncol = ncol, nrow = nrow)
  )
  panel_table$layout$name <- paste0("panel-", rep(seq_len(ncol), nrow),
                                    "-", rep(seq_len(nrow), each = ncol))
  panel_table <- gtable_add_col_space(panel_table,
                                      theme$panel.spacing.x %||%
                                        theme$panel.spacing)
  panel_table <- gtable_add_row_space(panel_table,
                                      theme$panel.spacing.y %||%
                                        theme$panel.spacing)
  # Reserve space for axes
  panel_table <- gtable_add_rows(panel_table, max_height(axes$x$top), 0)
  panel_table <- gtable_add_rows(panel_table, max_height(axes$x$bottom), -1)
  panel_table <- gtable_add_cols(panel_table, max_width(axes$y$left), 0)
  panel_table <- gtable_add_cols(panel_table, max_width(axes$y$right), -1)
  # Locate panels
  panel_pos_col  <- panel_cols(panel_table)
  panel_pos_rows <- panel_rows(panel_table)
  # Add top X axes
  panel_table <- gtable_add_grob(
    panel_table, axes$x$top, 1,
    panel_pos_col$l, clip = "off",
    name = paste0("axis-t-", seq_along(axes$x$top)),
    z = 3
  )
  # Add bottom X axes
  panel_table <- gtable_add_grob(
    panel_table, axes$x$bottom, -1,
    panel_pos_col$l, clip = "off",
    name = paste0("axis-b-", seq_along(axes$x$bottom)),
    z = 3
  )
  # Add left Y axes
  panel_table <- gtable_add_grob(
    panel_table, axes$y$left,
    panel_pos_rows$t, 1, clip = "off",
    name = paste0("axis-l-", seq_along(axes$y$left)),
    z = 3
  )
  # Add right Y axes
  panel_table <- gtable_add_grob(
    panel_table, axes$y$right,
    panel_pos_rows$t, -1, clip = "off",
    name = paste0("axis-r-", seq_along(axes$y$right)),
    z = 3
  )
  # Strip placement
  switch_x <- !is.null(params$switch) && params$switch %in% c("both", "x")
  switch_y <- !is.null(params$switch) && params$switch %in% c("both", "y")
  inside_x <- (theme$strip.placement.x %||%
                 theme$strip.placement %||% "inside") == "inside"
  inside_y <- (theme$strip.placement.y %||%
                 theme$strip.placement %||% "inside") == "inside"
  strip_padding <- convertUnit(theme$strip.switch.pad.grid, "cm")
  panel_pos_col <- panel_cols(panel_table)

  # Parse ideograms
  ideodat <- self$ideograms
  render.ideo <- self$render.ideo

  chr_style <- gsub("[0-9]{1,}X|Y|M", replacement = "", names(ideodat))
  chr_style <- names(sort(table(chr_style), decreasing = T))[1]

  chr_match_x <- apply(col_vars, 2, function(x) {
    sum(grepl(chr_style, x, ignore.case = T))
  })
  x_ideovars <- if (any(chr_match_x > 0)) {
    as.character(col_vars[, which.max(chr_match_x)])
  } else {
    rep(NA, nrow(col_vars))
  }

  chr_match_y <- apply(row_vars, 2, function(x) {
    sum(grepl(chr_style, x, ignore.case = T))
  })
  y_ideovars <- if (any(chr_match_y > 0)) {
    as.character(row_vars[, which.max(chr_match_y)])
  } else {
    rep(NA, nrow(row_vars))
  }

  x_ideos <- lapply(seq_along(x_ideovars), function(i){
    chr <- x_ideovars[[i]]
    ran <- ranges[[which(layout$COL == i)[[1]]]]
    render.ideo(chr, orient = "x", ranges = ran,
                theme = theme, high.col = params$high.col, ideodat = ideodat)
  })
  y_ideos <- lapply(seq_along(y_ideovars), function(i){
    chr <- y_ideovars[[i]]
    ran <- ranges[[which(layout$ROW == i)[[1]]]]
    render.ideo(chr, orient = "y", ranges = ran,
                theme = theme, high.col = params$high.col, ideodat = ideodat)
  })

  add_x_ideo <- !all(is.na(x_ideovars))
  add_y_ideo <- !all(is.na(y_ideovars))

  # Add X strips and ideos
  if (switch_x) {
    if (!is.null(strips$x$bottom)){
      if (inside_x) {
        if (add_x_ideo) {
          panel_table <- gtable_add_rows(panel_table, ideo.size, -2)
          panel_table <- gtable_add_grob(
            panel_table, x_ideos, -2,
            panel_pos_col$l, clip = "on",
            name = paste0("ideo-b-", seq_along(strips$x$bottom)),
            z = 3
          )
        }
        panel_table <- gtable_add_rows(panel_table,
                                       max_height(strips$x$bottom), -2)
        panel_table <- gtable_add_grob(
          panel_table, strips$x$bottom, -2,
          panel_pos_col$l, clip = "on",
          name = paste0("strip-b-", seq_along(strips$x$bottom)),
          z = 2
        )
      }
      else {
        panel_table <- gtable_add_rows(panel_table, strip_padding, -1)
        if (add_x_ideo) {
          panel_table <- gtable_add_rows(panel_table, ideo.size, -1)
          panel_table <- gtable_add_grob(
            panel_table, x_ideos, -1,
            panel_pos_col$l, clip = "on",
            name = paste0("ideo-b-", seq_along(strips$x$bottom)),
            z = 3
          )
        }
        panel_table <- gtable_add_rows(panel_table,
                                       max_height(strips$x$bottom), -1)
        panel_table <- gtable_add_grob(
          panel_table, strips$x$bottom, -1,
          panel_pos_col$l, clip = "on",
          name = paste0("strip-b-", seq_along(strips$x$bottom)),
          z = 2
        )
      }
    }
  }
  else {
    if (!is.null(strips$x$top)) {
      if (inside_x) {
        if (add_x_ideo) {
          panel_table <- gtable_add_rows(panel_table, ideo.size, 1)
          panel_table <- gtable_add_grob(
            panel_table, x_ideos, 2,
            panel_pos_col$l, clip = "on",
            name = paste0("ideo-t-", seq_along(strips$x$top)),
            z = 3
          )
        }
        panel_table <- gtable_add_rows(panel_table, max_height(strips$x$top), 1)
        panel_table <- gtable_add_grob(
          panel_table, strips$x$top,  2,
          panel_pos_col$l, clip = "on",
          name = paste0("strip-t-", seq_along(strips$x$top)),
          z = 2
        )
      }
      else {
        panel_table <- gtable_add_rows(panel_table, strip_padding, 0)
        if (add_x_ideo) {
          panel_table <- gtable_add_rows(panel_table, ideo.size, 0)
          panel_table <- gtable_add_grob(
            panel_table, x_ideos, 1,
            panel_pos_col$l, clip = "on",
            name = paste0("ideo-t-", seq_along(strips$x$top)),
            z = 3
          )
        }
        panel_table <- gtable_add_rows(panel_table, max_height(strips$x$top), 0)
        panel_table <- gtable_add_grob(
          panel_table, strips$x$top, 1,
          panel_pos_col$l, clip = "on",
          name = paste0("strip-t-", seq_along(strips$x$top)),
          z = 2
        )
      }
    }
  }

  # Recalibrate rows
  panel_pos_rows <- panel_rows(panel_table)

  # Add Y strips
  if (switch_y) {
    if (!is.null(strips$y$left)) {
      if (inside_y) {
        if (add_y_ideo) {
          panel_table <- gtable_add_cols(panel_table, ideo.size, 1)
          panel_table <- gtable_add_grob(
            panel_table, y_ideos,
            panel_pos_rows$t, 2, clip = "on",
            name = paste0("ideo-l-", seq_along(strips$y$left)),
            z = 3
          )
        }
        panel_table <- gtable_add_cols(panel_table, max_width(strips$y$left), 1)
        panel_table <- gtable_add_grob(
          panel_table, strips$y$left,
          panel_pos_rows$t, 2, clip = "on",
          name = paste0("strip-l-", seq_along(strips$y$left)),
          z = 2
        )
      }
      else {
        panel_table <- gtable_add_cols(panel_table, strip_padding, 0)
        if (add_y_ideo) {
          panel_table <- gtable_add_cols(panel_table, ideo.size, 0)
          panel_table <- gtable_add_grob(
            panel_table, y_ideos,
            panel_pos_rows$t, 1, clip = "on",
            name = paste0("ideo-l-", seq_along(strips$y$left)),
            z = 3
          )
        }
        panel_table <- gtable_add_cols(panel_table, max_width(strips$y$left), 0)
        panel_table <- gtable_add_grob(
          panel_table, strips$y$left,
          panel_pos_rows$t, 1, clip = "on",
          name = paste0("strip-l-", seq_along(strips$y$left)),
          z = 2
        )
      }
    }
  }
  else {
    if (!is.null(strips$y$right)) {
      if (inside_y) {
        if (add_y_ideo) {
          panel_table <- gtable_add_cols(panel_table, ideo.size, -2)
          panel_table <- gtable_add_grob(
            panel_table, y_ideos,
            panel_pos_rows$t, -2, clip = "on",
            name = paste0("ideo-r-", seq_along(strips$y$right)),
            z = 3
          )
        }
        panel_table <- gtable_add_cols(panel_table,
                                       max_width(strips$y$right), -2)
        panel_table <- gtable_add_grob(
          panel_table, strips$y$right,
          panel_pos_rows$t, -2, clip = "on",
          name = paste0("strip-r-", seq_along(strips$y$right)),
          z = 2
        )
      }
      else {
        panel_table <- gtable_add_cols(panel_table, strip_padding, -1)
        if (add_y_ideo) {
          panel_table <- gtable_add_cols(panel_table, ideo.size, -1)
          panel_table <- gtable_add_grob(
            panel_table, y_ideos,
            panel_pos_rows$t, -1, clip = "on",
            name = paste0("ideo-r-", seq_along(strips$y$right)),
            z = 3
          )
        }
        panel_table <- gtable_add_cols(panel_table,
                                       max_width(strips$y$right), -1)
        panel_table <- gtable_add_grob(
          panel_table, strips$y$right,
          panel_pos_rows$t, -1, clip = "on",
          name = paste0("strip-r-", seq_along(strips$y$right)),
          z = 2
        )
      }
    }
  }
  panel_table
}

#' Drawing panels for facet_ideowrap()
#'
#' This function handles the assembly of panels into a
#' \code{\link[gtable]{gtable}} object. This is a method of the "FacetIdeoWrap"
#' \code{\link[ggplot2]{ggproto}} class. This method recieves from objects
#' elsewhere in the plot a list of \code{\link[grid]{grid.grob}} with the
#' contents of panels. This method is responsible for decorating the panels with
#' axes, strips and ideograms and positioning these together in a gtable.
#'
#' @return A gtable object
#' @keywords internal
#'
#' @details Since this is a method of a class, this function should only be used
#'   indirectly by users.
draw_ideo_panels_wrap <- function(panels, layout, x_scales, y_scales,
                                  ranges, coord, data, theme, params, self) {
  if ( (params$free$x || params$free$y) && !coord$is_free()) {
    stop(.int$snake_class(coord), " doesn't support free scales", call. = FALSE)
  }
  if (inherits(coord, "CoordFlip")) {
    if (params$free$x) {
      layout$SCALE_X <- seq_len(nrow(layout))
    }
    else {
      layout$SCALE_X <- 1L
    }
    if (params$free$y) {
      layout$SCALE_Y <- seq_len(nrow(layout))
    } else {
      layout$SCALE_Y <- 1L
    }
  }

  ncol <- max(layout$COL)
  nrow <- max(layout$ROW)
  n <- nrow(layout)

  # Order layout and panels
  panel_order <- order(layout$ROW, layout$COL)
  layout <- layout[panel_order, ]
  panels <- panels[panel_order]
  panel_pos <- .int$convertInd(layout$ROW, layout$COL, nrow)

  axes <- render_axes(ranges, ranges, coord, theme, transpose = TRUE)

  if (length(params$facets) == 0) {
    labels_df <- data.frame(x = "(all)")
    names(labels_df) <- "(all)"
  } else {
    labels_df <- layout[names(params$facets)]
  }

  attr(labels_df, "facet") <- "wrap"
  strips <- render_strips(
    structure(labels_df, type = "rows"),
    structure(labels_df, type = "cols"),
    params$labeller, theme
  )
  aspect_ratio <- theme$aspect.ratio
  if (is.null(aspect_ratio) && !params$free$x && !params$free$y) {
    aspect_ratio <- coord$aspect(ranges[[1]])
  }
  if (is.null(aspect_ratio)) {
    aspect_ratio <- 1
    respect <- FALSE
  } else {
    respect <- TRUE
  }

  # Setup panel gtable
  empty_table <- matrix(list(zeroGrob()), nrow = nrow, ncol = ncol)
  panel_table <- empty_table
  panel_table[panel_pos] <- panels
  empties <- apply(panel_table, c(1, 2), function(x) .int$is.zero(x[[1]]))
  panel_table <- gtable_matrix(
    "layout", panel_table,
    widths  = unit(rep(1, ncol), "null"),
    heights = unit(rep(aspect_ratio, nrow), "null"),
    respect = respect, clip = coord$clip,
    z = matrix(1, ncol = ncol, nrow = nrow)
  )
  panel_table$layout$name <- paste0("panel-", rep(seq_len(ncol), nrow), "-",
                                   rep(seq_len(nrow), each = ncol))
  panel_table <- gtable_add_col_space(panel_table,
                                      theme$panel.spacing.x %||%
                                        theme$panel.spacing)
  panel_table <- gtable_add_row_space(panel_table,
                                      theme$panel.spacing.y %||%
                                        theme$panel.spacing)

  # Setup axes
  axis_mat_x_top <- empty_table
  axis_mat_x_top[panel_pos] <- axes$x$top[layout$SCALE_X]
  axis_mat_x_bottom <- empty_table
  axis_mat_x_bottom[panel_pos] <- axes$x$bottom[layout$SCALE_X]
  axis_mat_y_left <- empty_table
  axis_mat_y_left[panel_pos] <- axes$y$left[layout$SCALE_Y]
  axis_mat_y_right <- empty_table
  axis_mat_y_right[panel_pos] <- axes$y$right[layout$SCALE_Y]
  if (!params$free$x) {
    axis_mat_x_top[-1, ] <- list(zeroGrob())
    axis_mat_x_bottom[-nrow, ] <- list(zeroGrob())
  }
  if (!params$free$y) {
    axis_mat_y_left[, -1] <- list(zeroGrob())
    axis_mat_y_right[, -ncol] <- list(zeroGrob())
  }
  axis_height_top <- unit(apply(axis_mat_x_top, 1, max_height), "cm")
  axis_height_bottom <- unit(apply(axis_mat_x_bottom, 1, max_height), "cm")
  axis_width_left <- unit(apply(axis_mat_y_left, 2, max_width), "cm")
  axis_width_right <- unit(apply(axis_mat_y_right, 2, max_width), "cm")

  # Handle empties
  if (any(empties)) {
    first_row <- which(apply(empties, 1, any))[1] - 1
    first_col <- which(apply(empties, 2, any))[1] - 1

    row_panels <- which(layout$ROW == first_row & layout$COL > first_col)
    row_pos <- .int$convertInd(layout$ROW[row_panels],
                               layout$COL[row_panels], nrow)
    row_axes <- axes$x$bottom[layout$SCALE_X[row_panels]]

    col_panels <- which(layout$ROW > first_row & layout$COL == first_col)
    col_pos <- .int$convertInd(layout$ROW[col_panels],
                               layout$COL[col_panels], nrow)
    col_axes <- axes$y$right[layout$SCALE_Y[col_panels]]

    if (params$strip.position == "bottom" &&
        theme$strip.placement != "inside" &&
        any(!vapply(row_axes, .int$is.zero, logical(1))) && !params$free$x) {
      warning("Suppressing axis rendering when strip.position = 'bottom'
              and strip.placement == 'outside'",
              call. = FALSE)
    }
    else {
      axis_mat_x_bottom[row_pos] <- row_axes
    }
    if (params$strip.position == "right" && theme$strip.placement != "inside" &&
        !params$free$y){
      warning("Suppressing axis rendering when strip.position = 'right'
              and strip.placement == 'outside'",
              call. = FALSE)
    }
    else {
      axis_mat_y_right[col_pos] <- col_axes
    }
  }

  # Build out gtables
  panel_table <- .int$weave_tables_row(panel_table, axis_mat_x_top,
                                            -1, axis_height_top, "axis-t", 3)
  panel_table <- .int$weave_tables_row(panel_table, axis_mat_x_bottom,
                                            0, axis_height_bottom, "axis-b", 3)
  panel_table <- .int$weave_tables_col(panel_table, axis_mat_y_left,
                                            -1, axis_width_left, "axis-l", 3)
  panel_table <- .int$weave_tables_col(panel_table, axis_mat_y_right,
                                            0, axis_width_right, "axis-r", 3)

  # Do strips
  strip_padding <- convertUnit(theme$strip.switch.pad.wrap, "cm")
  strip_name <- paste0("strip-", substr(params$strip.position, 1, 1))
  strip_mat <- empty_table
  strip_mat[panel_pos] <- unlist(unname(strips),
                                 recursive = FALSE)[[params$strip.position]]

  # Do ideograms
  ideodat <- self$ideograms
  render.ideo <- self$render.ideo

  chr_style <- gsub("[0-9]{1,}X|Y|M", replacement = "", names(ideodat))
  chr_style <- names(sort(table(chr_style), decreasing = T))[1]

  chr_match <- apply(labels_df, 2, function(x) {
    sum(grepl(chr_style, x, ignore.case = T))
  })
  ideovars <- if (any(chr_match > 0)) {
    as.character(labels_df[, which.max(chr_match)])
  } else {
    rep(NA, nrow(unique(layout[names(params$cols)])))
  }

  orient <- if (params$strip.position %in% c("top", "bottom")) {
    "x"
  } else {
    "y"
  }

  ideos <- lapply(seq_along(ideovars), function(i){
    chr <- ideovars[[i]]
    ran <- ranges[[which(as.numeric(layout$PANEL) == i)]]
    grob <- render.ideo(chr, orient = orient, ranges = ran,
                        theme = theme, high.col = params$high.col,
                        ideodat = ideodat)
    gtable_matrix("ideo", matrix(list(grob)),
                  widths = unit(1, "null"),
                  heights = unit(1, "null"))
  })
  ideonames <- paste0("ideo-", seq_along(ideovars))

  add_ideo <- !all(is.na(ideovars))

  if (add_ideo) {
    ideo_mat <- empty_table
    ideo_mat[panel_pos] <- ideos
  }

  if (params$strip.position %in% c("top", "bottom")) {
    inside <- (theme$strip.placement.x %||%
                 theme$strip.placement %||% "inside") == "inside"
    if (params$strip.position == "top") {
      placement <- if (inside)
        -1
      else -2
      strip_pad <- axis_height_top
    }
    else {
      placement <- if (inside)
        0
      else 1
      strip_pad <- axis_height_bottom
    }
    strip_height <- unit(apply(strip_mat, 1, max_height), "cm")
    panel_table <- .int$weave_tables_row(
      panel_table, strip_mat, placement,
      strip_height, strip_name, 2, coord$clip
    )
    if (add_ideo) {
      ideo_height <- rep(params$ideo.size, length(strip_height))
      panel_table <- .int$weave_tables_row(
        panel_table, ideo_mat, placement,
        ideo_height, "ideo", 2, coord$clip
      )
    }
    if (!inside) {
      # Padding
      strip_pad[unclass(strip_pad) != 0] <- strip_padding
      panel_table <- .int$weave_tables_row(panel_table, row_shift = placement,
                                                row_height = strip_pad)
    }
  }
  else {
    inside <- (theme$strip.placement.y %||%
                 theme$strip.placement %||% "inside") == "inside"
    if (params$strip.position == "left") {
      placement <- if (inside)
        -1
      else - 2
      strip_pad <- axis_width_left
    }
    else {
      placement <- if (inside)
        0
      else 1
      strip_pad <- axis_width_right
    }
    strip_pad[unclass(strip_pad) != 0] <- strip_padding
    strip_width <- unit(apply(strip_mat, 2, max_width), "cm")
    panel_table <- .int$weave_tables_col(
      panel_table, strip_mat,
      placement, strip_width, strip_name, 2, coord$clip
    )
    if (add_ideo) {
      ideo_width <- rep(params$ideo.size, length(strip_width))
      panel_table <- .int$weave_tables_col(panel_table, ideo_mat, placement,
                                                ideo_width,
                                                "ideo", 2, coord$clip)
    }
    if (!inside) {
      strip_pad[unclass(strip_pad) != 0] <- strip_padding
      panel_table <- .int$weave_tables_col(
        panel_table, col_shift = placement, col_width = strip_pad
      )
    }
  }
  panel_table
}
